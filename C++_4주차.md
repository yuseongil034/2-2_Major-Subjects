# C++ 함수와 문자열 완벽 정리 📚

> 한밭대학교 C++ 언어 프로그래밍 4주차 강의 내용을 바탕으로 작성되었습니다.

---

## 목차

1. [함수의 기본 개념](#1-함수의-기본-개념)
2. [함수 선언과 호출](#2-함수-선언과-호출)
3. [인수 전달 방법](#3-인수-전달-방법)
4. [중복 함수 (Function Overloading)](#4-중복-함수-function-overloading)
5. [디폴트 매개변수](#5-디폴트-매개변수)
6. [인라인 함수](#6-인라인-함수)
7. [string 클래스](#7-string-클래스)

---

## 1. 함수의 기본 개념

### 함수란? 🤔

함수는 **특정 작업을 수행하는 블랙박스**라고 생각하면 됩니다.

**비유**: 자판기를 떠올려보세요.
- 동전을 넣으면 (입력) → 자판기가 작동해서 (처리) → 음료수가 나옵니다 (출력)
- 함수도 이와 똑같습니다!

### 함수를 사용하는 이유

- ✅ **코드 재사용**: 같은 코드를 여러 번 쓸 필요 없음
- ✅ **가독성 향상**: 코드가 깔끔하고 이해하기 쉬워짐
- ✅ **유지보수 용이**: 문제가 생기면 해당 함수만 수정하면 됨

---

## 2. 함수 선언과 호출

### 함수의 구조

```cpp
반환형 함수이름(매개변수1, 매개변수2, ...) {
    // 수행할 작업
    return 결과값;
}
```

**예시**: 두 수 중 큰 값을 반환하는 함수

```cpp
#include <iostream>
using namespace std;

// 함수 정의
int max(int x, int y) {
    if (x > y)
        return x;
    else
        return y;
}

int main() {
    int result = max(2, 3);  // 함수 호출
    cout << "결과 = " << result << endl;  // 출력: 결과 = 3
    return 0;
}
```

### 함수 원형 (Function Prototype)

함수를 `main()` 아래에 정의하고 싶다면, **미리 함수 원형을 선언**해야 합니다.

```cpp
#include <iostream>
using namespace std;

int square(int n);  // 함수 원형 선언

int main() {
    cout << square(5) << endl;  // 출력: 25
    return 0;
}

int square(int n) {  // 실제 함수 정의
    return n * n;
}
```

**왜 필요할까?**
- C++은 위에서 아래로 코드를 읽습니다
- `main()`에서 `square()`를 호출하는데, 아래에 정의되어 있으면 컴파일러가 "이게 뭔지 모르겠는데?" 하고 에러를 냅니다
- 함수 원형을 선언하면 컴파일러에게 "아, 이런 함수가 나중에 나올 거야"라고 미리 알려주는 것입니다

---

## 3. 인수 전달 방법

함수에 값을 전달하는 방법은 크게 **2가지**가 있습니다.

### 3.1 값으로 전달 (Call by Value)

**복사본**을 전달하는 방식입니다.

```cpp
void addTen(int x) {
    x = x + 10;  // x는 복사본이므로 원본은 변하지 않음
}

int main() {
    int num = 5;
    addTen(num);
    cout << num << endl;  // 출력: 5 (변하지 않음!)
    return 0;
}
```

**비유**: 사진을 복사해서 친구에게 줬는데, 친구가 그 사진에 낙서를 해도 내 원본 사진은 깨끗합니다.

### 3.2 참조로 전달 (Call by Reference)

**원본 자체**를 전달하는 방식입니다. `&` 기호를 사용합니다.

```cpp
void addTen(int &x) {  // & 기호 주목!
    x = x + 10;  // 원본이 변경됨
}

int main() {
    int num = 5;
    addTen(num);
    cout << num << endl;  // 출력: 15 (변했다!)
    return 0;
}
```

**비유**: 친구에게 원본 사진을 직접 줬는데, 친구가 낙서를 하면 내 사진도 낙서가 됩니다.

### 참조자(Reference)란?

참조자는 **변수의 별명**입니다.

```cpp
int var = 10;
int &ref = var;  // ref는 var의 별명

ref = 20;  // ref를 바꾸면
cout << var << endl;  // var도 20으로 변함!
```

### 실전 예제: swap() 함수

두 변수의 값을 바꾸는 함수를 만들어봅시다.

```cpp
#include <iostream>
using namespace std;

void swap(int &x, int &y) {  // 참조로 전달!
    int tmp = x;
    x = y;
    y = tmp;
}

int main() {
    int a = 100, b = 200;
    cout << "교환 전: " << a << ", " << b << endl;  // 100, 200
    
    swap(a, b);
    
    cout << "교환 후: " << a << ", " << b << endl;  // 200, 100
    return 0;
}
```

⚠️ **주의**: 만약 `&`를 빼고 `void swap(int x, int y)`로 쓰면, 복사본만 바뀌고 원본은 안 바뀝니다!

---

## 4. 중복 함수 (Function Overloading)

같은 이름의 함수를 **여러 개** 만들 수 있습니다! 단, **매개변수가 달라야** 합니다.

### 기본 개념

```cpp
// 정수를 제곱
int square(int i) {
    return i * i;
}

// 실수를 제곱
double square(double i) {
    return i * i;
}

int main() {
    cout << square(5) << endl;      // 첫 번째 함수 호출 → 25
    cout << square(2.5) << endl;    // 두 번째 함수 호출 → 6.25
    return 0;
}
```

**어떻게 구분할까?**
- 컴파일러가 **매개변수의 타입**을 보고 알아서 맞는 함수를 선택합니다
- 이를 **시그니처(Signature)**라고 합니다

### 시그니처란?

함수의 **매개변수 개수, 타입, 순서**를 말합니다.

```cpp
void print(int i);           // 시그니처: int
void print(double d);        // 시그니처: double
void print(int i, int j);    // 시그니처: int, int
```

### ❌ 불가능한 경우

```cpp
int square(int i) {
    return i * i;
}

double square(int i) {  // 에러! 매개변수가 같음
    return i * i;
}
```

**반환형만 다르면 안 됩니다!** 매개변수가 달라야 합니다.

**왜일까?**
- `square(5)`를 호출하면, 컴파일러는 "5는 int니까... 어느 함수를 호출해야 하지?"라고 혼란스러워합니다
- 두 함수 모두 `int`를 받으니까 구분할 수 없습니다

### 실전 예제: 다양한 타입을 출력하는 함수

```cpp
#include <iostream>
using namespace std;

void print(int i) {
    cout << "정수: " << i << endl;
}

void print(double f) {
    cout << "실수: " << f << endl;
}

void print(char c) {
    cout << "문자: " << c << endl;
}

int main() {
    print(100);    // 정수: 100
    print(3.14);   // 실수: 3.14
    print('A');    // 문자: A
    return 0;
}
```

---

## 5. 디폴트 매개변수

매개변수에 **기본값**을 설정할 수 있습니다.

### 기본 사용법

```cpp
void display(char c = '*', int n = 10) {
    for (int i = 0; i < n; i++)
        cout << c;
    cout << endl;
}

int main() {
    display();           // **********  (기본값 사용)
    display('#');        // ##########  (c만 변경)
    display('#', 5);     // #####       (둘 다 변경)
    return 0;
}
```

### ⚠️ 중요한 규칙

**디폴트 매개변수는 오른쪽부터 채워져야 합니다!**

```cpp
// ✅ 올바른 예
int sub(int a, int b = 100, int c = 100);

// ❌ 잘못된 예
int sub(int a = 100, int b, int c = 100);  // 에러!
```

**왜일까?**

함수 호출 시 매개변수는 **왼쪽부터** 전달됩니다.

```cpp
int sub(int a, int b = 100, int c = 100);

sub(10);           // a=10, b=100, c=100
sub(10, 20);       // a=10, b=20, c=100
sub(10, 20, 30);   // a=10, b=20, c=30
```

만약 `int sub(int a = 100, int b, int c = 100)`이라면,
- `sub(10)`을 호출하면 `a=10`인지 `b=10`인지 알 수 없습니다!

### 중복 함수 대신 디폴트 매개변수 사용하기

**Before (중복 함수)**:

```cpp
int sum(int x, int y) {
    return x + y;
}

int sum(int x, int y, int z) {
    return x + y + z;
}

int sum(int x, int y, int z, int w) {
    return x + y + z + w;
}
```

**After (디폴트 매개변수)**:

```cpp
int sum(int x, int y, int z = 0, int w = 0) {
    return x + y + z + w;
}

int main() {
    cout << sum(10, 15) << endl;           // 25
    cout << sum(10, 15, 25) << endl;       // 50
    cout << sum(10, 15, 25, 30) << endl;   // 80
    return 0;
}
```

훨씬 간단하죠? 🎉

---

## 6. 인라인 함수

### 함수 호출의 비밀

함수를 호출하면 **오버헤드(Overhead)**가 발생합니다.

**오버헤드란?**
- 함수를 호출할 때 추가로 드는 시간/메모리
- 함수 위치로 점프하고, 돌아오는 과정에서 발생

**비유**: 친구에게 물어보려고 다른 건물로 가는 것 vs 옆에서 바로 물어보는 것

### 인라인 함수의 원리

`inline` 키워드를 사용하면, 컴파일러가 함수를 **직접 코드에 삽입**합니다.

```cpp
inline double square(double x) {
    return x * x;
}

int main() {
    double result = square(5.0);  // 컴파일러가 아래처럼 변환
    // double result = 5.0 * 5.0;
    return 0;
}
```

### 언제 사용할까?

- ✅ **짧고 자주 호출되는 함수**
- ❌ 복잡하거나 긴 함수 (효과 없음)

---

## 7. string 클래스

C++에서는 문자열을 쉽게 다룰 수 있는 `string` 클래스를 제공합니다.

### C 언어 vs C++

**C 언어**:
```c
char str[100] = "Hello";  // 배열로 관리, 불편함
```

**C++**:
```cpp
#include <string>
string str = "Hello";  // 간단하고 안전!
```

### 7.1 문자열 결합

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s1 = "Slow", s2 = "steady";
    string s3 = "the race.";
    
    string result = s1 + " and " + s2 + " wins " + s3;
    cout << result << endl;
    // 출력: Slow and steady wins the race.
    
    return 0;
}
```

### 7.2 문자열 비교

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s1 = "Hello", s2 = "World";
    
    if (s1 == s2)
        cout << "같습니다" << endl;
    else
        cout << "다릅니다" << endl;  // 이게 출력됨
    
    if (s1 < s2)
        cout << "s1이 사전순으로 앞" << endl;  // 이게 출력됨
    else
        cout << "s2가 사전순으로 앞" << endl;
    
    return 0;
}
```

**사전순 비교란?**
- 'A' < 'B' < 'C' ... < 'Z'
- "Hello"는 "World"보다 앞에 있습니다

### 7.3 문자열 입력 받기

#### 기본 입력 (띄어쓰기 전까지)

```cpp
string name;
cin >> name;  // "Hong Gil Dong" 입력 → "Hong"만 저장됨
```

#### 한 줄 전체 입력 (getline)

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string name, address;
    
    cout << "이름: ";
    cin >> name;
    
    cin.ignore();  // ⚠️ 중요! 엔터키 제거
    
    cout << "주소: ";
    getline(cin, address);  // 띄어쓰기 포함 전체 입력
    
    cout << address << "의 " << name << "씨 안녕하세요!" << endl;
    return 0;
}
```

**왜 `cin.ignore()`가 필요할까?**

1. `cin >> name`으로 "홍길동" 입력 후 엔터
2. 버퍼에 "홍길동\n" 저장
3. `cin`은 "홍길동"만 가져가고 **'\n'은 버퍼에 남음**
4. `getline()`이 남은 '\n'을 읽어서 바로 종료됨
5. **`cin.ignore()`로 '\n'을 제거**해야 함!

### 7.4 유용한 string 함수들

| 함수 | 설명 | 예시 |
|------|------|------|
| `s.length()` | 문자열 길이 | `"Hello".length()` → 5 |
| `s[i]` | i번째 문자 | `"Hello"[0]` → 'H' |
| `s.find(str)` | 문자열 찾기 | `"Hello".find("ll")` → 2 |
| `s.erase(pos, len)` | 일부 삭제 | `"Hello".erase(1, 2)` → "Hlo" |
| `s.substr(pos, len)` | 부분 문자열 | `"Hello".substr(1, 3)` → "ell" |

### 실전 예제 1: 문자열에서 특정 단어 찾기

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string sentence = "When in Rome, do as the Romans.";
    int index = sentence.find("Rome");
    
    if (index != string::npos)  // 찾았으면
        cout << "위치: " << index << endl;  // 출력: 위치: 8
    else
        cout << "못 찾음" << endl;
    
    return 0;
}
```

**`string::npos`란?**
- "not found"를 의미하는 특별한 값
- `find()`가 실패하면 이 값을 반환

### 실전 예제 2: 주민등록번호에서 '-' 제거

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string ssn;
    cout << "주민등록번호: ";
    cin >> ssn;  // 예: 990101-1234567
    
    cout << "'-' 제거: " << ssn.erase(6, 1) << endl;
    // 출력: 9901011234567
    
    return 0;
}
```

**또 다른 방법 (반복문 사용)**:

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string ssn;
    cout << "주민등록번호: ";
    cin >> ssn;
    
    cout << "'-' 제거: ";
    for (char c : ssn) {  // 범위 기반 for문
        if (c == '-')
            continue;  // '-'는 건너뛰기
        cout << c;
    }
    cout << endl;
    
    return 0;
}
```

### 실전 예제 3: 해밍 거리 (Hamming Distance)

두 문자열에서 **다른 위치의 개수**를 세는 프로그램입니다.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s1, s2;
    int count = 0;
    
    cout << "DNA1: ";
    cin >> s1;
    cout << "DNA2: ";
    cin >> s2;
    
    if (s1.length() != s2.length()) {
        cout << "오류: 길이가 다름" << endl;
    } else {
        for (int i = 0; i < s1.length(); i++) {
            if (s1[i] != s2[i])
                count++;
        }
        cout << "해밍 거리: " << count << endl;
    }
    
    return 0;
}
```

**예시**:
```
DNA1: AGCT
DNA2: AACT
해밍 거리: 1  (두 번째 문자만 다름)
```

### 실전 예제 4: 행맨 게임

단어를 맞추는 게임입니다.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    char ch;
    string solution = "c++";
    string guess = "___";  // 처음엔 모두 밑줄
    
    while (true) {
        cout << guess << endl;
        cout << "글자 입력: ";
        cin >> ch;
        
        // 입력한 글자가 정답에 있는지 확인
        for (int i = 0; i < solution.length(); i++) {
            if (ch == solution[i]) {
                guess[i] = ch;  // 맞으면 공개
            }
        }
        
        // 모두 맞췄는지 확인
        if (solution == guess) {
            cout << solution << endl;
            cout << "성공!" << endl;
            break;
        }
    }
    
    return 0;
}
```

**실행 예시**:
```
___
글자 입력: c
c__
글자 입력: +
c++
성공!
```

---

## 📝 핵심 요약

### 함수 관련
- **함수**: 특정 작업을 수행하는 코드 블록
- **값 전달**: 복사본 전달 (원본 안 바뀜)
- **참조 전달**: 원본 전달 (`&` 사용, 원본 바뀜)
- **중복 함수**: 같은 이름, 다른 매개변수
- **디폴트 매개변수**: 기본값 설정 (오른쪽부터!)
- **인라인 함수**: 짧은 함수의 성능 향상

### string 관련
- **결합**: `s1 + s2`
- **비교**: `s1 == s2`, `s1 < s2`
- **길이**: `s.length()`
- **접근**: `s[i]`
- **찾기**: `s.find(str)`
- **삭제**: `s.erase(pos, len)`
- **입력**: `getline(cin, s)` (띄어쓰기 포함)

---

## ⚠️ 주의사항

1. **참조 전달** 시 `&` 기호 잊지 말기
2. **디폴트 매개변수**는 오른쪽부터 채우기
3. **중복 함수**는 매개변수가 달라야 함 (반환형만 다르면 안 됨)
4. **getline() 사용 전** `cin.ignore()` 호출하기
5. **find() 결과**는 `string::npos`와 비교하기

---

## 🎯 연습 문제

### 문제 1: 세 수의 최댓값
세 개의 정수를 받아서 가장 큰 값을 반환하는 함수를 작성하세요.

```cpp
int max3(int a, int b, int c) {
    // 여기에 코드 작성
}
```

<details>
<summary>정답 보기</summary>

```cpp
int max3(int a, int b, int c) {
    int max_val = a;
    if (b > max_val) max_val = b;
    if (c > max_val) max_val = c;
    return max_val;
}
```

</details>

### 문제 2: 배열 합계 (참조 사용)
배열과 그 크기를 받아서, 배열의 합을 참조 매개변수에 저장하는 함수를 작성하세요.

```cpp
void arraySum(int arr[], int size, int &sum) {
    // 여기에 코드 작성
}
```

<details>
<summary>정답 보기</summary>

```cpp
void arraySum(int arr[], int size, int &sum) {
    sum = 0;
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
}
```

</details>

### 문제 3: 회문 검사
문자열이 회문(앞뒤가 같은 단어)인지 확인하는 함수를 작성하세요.

```cpp
bool isPalindrome(string s) {
    // 여기에 코드 작성
}
```

<details>
<summary>정답 보기</summary>

```cpp
bool isPalindrome(string s) {
    int len = s.length();
    for (int i = 0; i < len / 2; i++) {
        if (s[i] != s[len - 1 - i])
            return false;
    }
    return true;
}
```

</details>

---

이 문서가 C++ 함수와 문자열을 이해하는 데 도움이 되었기를 바랍니다! 🚀

궁금한 점이 있다면 언제든지 질문해주세요! 💬
