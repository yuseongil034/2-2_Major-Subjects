# C++ 객체지향 프로그래밍 개념 정리

## 📌 핵심 개념 정정 및 보충

### 1. 추상화 vs 캡슐화 (중요!)

#### ❌ 틀린 개념
"상태는 변수 동작은 함수에 대응 되는 느낌인데 이것을 추상화라고 한다"

#### ✅ 정확한 개념
- **추상화(Abstraction)**: 문제 해결에 **필요한 것만 선택**하는 것
  - 예: 자동차를 만들 때 모델, 색상, 가격, 속도, 기어 등 중에서 프로그램에 필요한 것만 선택
  - "속도, 기어, 색상만 선택" ← 이게 추상화!

- **캡슐화(Encapsulation)**: 데이터(변수)와 함수를 **하나로 묶는** 것
  - 상태 → 멤버 변수, 동작 → 멤버 함수로 묶어서 객체 만들기
  - 클래스로 변수와 함수를 묶는 것이 캡슐화!

---

## 📘 클래스 기본 구조

### 클래스 선언
```cpp
class Circle {  // 클래스 이름 (명사, 첫 글자 대문자)
private:        // 접근 지정자
    int radius;    // 멤버 변수
    
public:
    void draw() {  // 멤버 함수
        // ...
    }
};
```

### 💡 꿀팁: 네이밍 규칙
- **클래스 이름**: 명사, 첫 글자 대문자 (Circle, Car, Rectangle)
- **멤버 함수 이름**: 동사(소문자) + 명사(대문자) (calcArea, speedUp, draw)

---

## 🔐 접근 지정자 (Access Specifier)

### public vs private

| 구분 | 외부 접근 | 내부 접근 | 사용 예 |
|------|-----------|-----------|---------|
| **public** | ⭕ 가능 | ⭕ 가능 | 멤버 함수, 생성자 |
| **private** | ❌ 불가능 | ⭕ 가능 | 멤버 변수 (정보 은닉) |

### Private 접근 방법

#### ❌ 틀린 개념
"private는 함수나 변수로 놓고 그 변수의 값을 넣으면 사용 가능하다"

#### ✅ 정확한 개념
Private 멤버에 접근하는 2가지 방법:

**방법 1: public 멤버 함수 사용**
```cpp
class Rectangle {
private:
    int width, height;  // private 변수
public:
    void init(int w, int h) {  // public 함수로 접근
        width = w;   // 클래스 내부에서는 접근 가능!
        height = h;
    }
};

int main() {
    Rectangle obj;
    obj.init(5, 5);  // public 함수를 통해 간접 접근
}
```

**방법 2: 생성자 사용 (가장 일반적!)**
```cpp
class Rectangle {
private:
    int width, height;
public:
    Rectangle(int w, int h) {  // 생성자
        width = w;
        height = h;
    }
};

int main() {
    Rectangle obj{5, 5};  // 생성 시 값 초기화
}
```

---

## 🎯 생성자 (Constructor)

### 생성자의 특징

#### ✅ 맞는 개념
- 반환형이 없다
- 클래스 이름과 동일
- 객체 생성 시 자동 실행
- 생성하면서 값 초기화 가능

#### ❌ 틀린 표현
"매개변수의 이름이 없고 클래스랑 이름이 같아야됨"

#### ✅ 정정
"**반환형**이 없고 클래스랑 이름이 같아야됨" (매개변수는 있어요!)

### 생성자 예제
```cpp
class Circle {
private:
    int radius;
    int x, y;
    
public:
    // 생성자: 반환형 없음, 클래스 이름과 동일
    Circle(int r, int x_pos, int y_pos) {  // 매개변수 있음!
        radius = r;
        x = x_pos;
        y = y_pos;
    }
};

int main() {
    Circle c1{50, 100, 200};  // 생성과 동시에 초기화
    // Circle c1;  // ❌ 에러! 생성자가 있으면 반드시 인자 전달
}
```

---

## 📍 객체 멤버 접근 (도트 연산자)

### 접근 규칙
```cpp
class Circle {
public:
    int radius;     // public 변수
    void draw() {}  // public 함수
private:
    int x, y;       // private 변수
};

int main() {
    Circle obj;
    
    // ⭕ 가능: public 멤버 접근
    obj.radius = 10;
    obj.draw();
    
    // ❌ 불가능: private 멤버 접근
    // obj.x = 5;  // 컴파일 에러!
}
```

---

## 🔑 정보 은닉 (Information Hiding)

### 왜 private를 사용할까?

#### 목적
1. **데이터 보호**: 외부에서 잘못된 값 설정 방지
2. **유지보수성**: 내부 구현 변경 시 외부 코드 영향 최소화
3. **인터페이스 단순화**: 필요한 기능만 공개

#### 일반적인 패턴
```cpp
class BankAccount {
private:
    int balance;  // 변수는 private (데이터 은닉)
    
public:
    // 함수는 public (인터페이스 제공)
    void deposit(int amount) {
        if (amount > 0)  // 유효성 검사 가능!
            balance += amount;
    }
    
    int getBalance() {
        return balance;
    }
};
```

### 💡 시험 꿀팁
- **변수는 private, 함수는 public**이 기본 패턴
- 생성자는 무조건 public!
- "정보 은닉성 향상"이라는 표현 외우기

---

## 🎓 객체지향 4대 특성 정리

| 특성 | 의미 | 구현 방법 |
|------|------|-----------|
| **추상화** | 필요한 것만 선택 | 클래스 설계 시 멤버 선택 |
| **캡슐화** | 데이터+함수 묶기 | 클래스로 멤버 변수+함수 묶음 |
| **정보은닉** | 내부 구현 숨기기 | private 접근 지정자 |
| **상속** | 기존 클래스 재사용 | (11장에서 학습) |
| **다형성** | 상황에 따라 다른 동작 | (12장에서 학습) |

---

## 📝 시험 대비 체크리스트

### 꼭 기억할 것들
- [ ] 클래스 = 객체를 만드는 **설계도/틀**
- [ ] 인스턴스 = 클래스로 만든 **실제 객체**
- [ ] public = 외부 접근 ⭕, private = 외부 접근 ❌
- [ ] 생성자 = 반환형 없음 + 클래스명과 동일 + 객체 생성 시 자동 호출
- [ ] 도트 연산자(.) = 객체의 public 멤버 접근
- [ ] 캡슐화 ≠ 추상화 (개념 구분!)

### 코딩 패턴
```cpp
class ClassName {
private:
    // 멤버 변수 (데이터 은닉)
    int variable;
    
public:
    // 생성자 (초기화)
    ClassName(int v) {
        variable = v;
    }
    
    // 멤버 함수 (동작)
    void function() {
        // 내부에서는 private 접근 가능
    }
};
```

---

## 💪 실전 문제 풀이 팁

### 문제 유형별 접근법

#### 1. 클래스 설계 문제
1. 필요한 상태(변수) 파악 → private
2. 필요한 동작(함수) 파악 → public
3. 생성자 필요 여부 확인

#### 2. Private 멤버 문제
- 접근 불가 에러 → 생성자나 public 함수 추가

#### 3. 객체 생성 문제
```cpp
// 생성자 없을 때
ClassName obj;
obj.member = value;

// 생성자 있을 때
ClassName obj{value1, value2};
```

### 자주 하는 실수
1. ❌ `obj.private변수 = 값;` → 외부에서 private 접근
2. ❌ 생성자에 반환형 쓰기 → `void Circle() {}`
3. ❌ 생성자 이름 오타 → 클래스명과 정확히 일치해야 함

---

## 🚀 다음 학습 목표
- 생성자 오버로딩 (여러 생성자 만들기)
- 소멸자 (Destructor)
- 멤버 함수 외부 정의 (::연산자)
- 상속과 다형성 (11, 12장)
