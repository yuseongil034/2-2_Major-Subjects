# OSI 7계층 완벽 정리 📚

> **시험 필수 암기 사항!** OSI 7계층의 각 계층별 기능과 특징을 명확하게 구별할 수 있도록 정리했습니다.

---

## 📌 OSI 7계층 개요

OSI(Open Systems Interconnection) 7계층은 네트워크 통신을 **7개의 논리적 계층**으로 나눈 모델입니다.

**계층 구조 (위에서 아래로)**
1. **응용 계층 (Application Layer)** - 사용자 인터페이스
2. **표현 계층 (Presentation Layer)** - 데이터 형식 변환
3. **세션 계층 (Session Layer)** - 연결 관리
4. **전송 계층 (Transport Layer)** - 종단 간 신뢰성
5. **네트워크 계층 (Network Layer)** - 경로 설정
6. **데이터 링크 계층 (Data Link Layer)** - 노드 간 전달
7. **물리 계층 (Physical Layer)** - 비트 전송

---

## 1️⃣ 물리 계층 (Physical Layer)

**가장 아래 계층으로, 실제 물리적인 신호를 전송합니다.**

### 주요 기능
- 비트(0과 1)를 전기 신호, 광 신호, 전파 등으로 변환
- 케이블, 커넥터 등 물리적 매체 규정

### 키워드
`비트`, `전기 신호`, `케이블`, `허브`

---

## 2️⃣ 데이터 링크 계층 (Data Link Layer) ⭐

**물리 계층 바로 위 계층으로, 노드 대 노드(Node-to-Node) 전달을 담당합니다.**

### 주요 기능

#### 1. 노드 대 노드 전달 & 주소 지정
- 데이터 앞에 **헤더(Header)**를 붙임
- 헤더에는 **발신지 주소**와 **목적지 주소** 포함
- 같은 네트워크 내의 두 노드 간 데이터 전달

#### 2. 전송 제어

**🔹 교환 회선 방식**
```
회선 접속 → 데이터 링크 확립 → 정보 전송 → 데이터 링크 해제 → 회선 절단
```

**🔹 전용 회선 방식**
```
데이터 링크 확립 → 정보 전송 → 데이터 링크 해제
```
> 전용 회선은 이미 연결이 확립되어 있으므로 **회선 접속/절단 과정 생략**

---

### 3. 흐름 제어 (Flow Control)

송신 측과 수신 측의 데이터 처리 속도 차이를 해결하는 기법

#### 📍 정지 대기 방식 (Stop-and-Wait)

**동작 방식:**
1. 송신 측에서 데이터 1개 전송
2. 수신 측에서 **ACK**(긍정 응답) 또는 **NAK**(부정 응답) 전송
3. ACK를 받으면 다음 데이터 전송, NAK를 받으면 재전송

**특징:**
- ✅ 에러 검출이 확실함
- ❌ 전송 효율이 낮음 (대기 시간이 김)
- **사용 예:** 이메일, 파일 전송 등 **정확성이 중요한 경우**

#### 📍 슬라이딩 윈도우 방식 (Sliding Window)

**동작 방식:**
- 응답을 기다리지 않고 **여러 개의 프레임을 연속적으로 전송**
- 수신 측은 받은 순서대로 ACK 전송
- 윈도우 크기만큼 한 번에 전송 가능

**특징:**
- ✅ 전송 효율이 높음
- ✅ 약간의 에러는 허용 가능
- **사용 예:** 음성 통화, 동영상 스트리밍 등 **실시간성이 중요한 경우** 또는 **거리가 가까워서 에러 확률이 낮은 경우**

---

### 4. 오류 제어 (Error Control) 🚨

**목적:** ACK/NAK를 보내기 위해 오류를 검사

#### 오류 제어 방식 4가지

| 방식 | 설명 | 특징 |
|------|------|------|
| **오류 무시** | 오류 검사를 하지 않음 | 슬라이딩 윈도우 방식에서 사용 |
| **반향 검사 (Echo)** | 전송 데이터와 수신 데이터를 비교 | 시간이 오래 걸리지만 확실함 |
| **검출 후 재전송 (ARQ)** | 오류 발생 시 재전송 요구 | ACK/NAK 사용 |
| **전진 오류 수정 (FEC)** | 오류를 검출하고 수정까지 진행 | 자기 정정 방식 |

---

#### 🔥 ARQ (Automatic Repeat reQuest) 방식의 종류 - 시험 중요!

**1. 정지 대기 ARQ (Stop-and-Wait ARQ)**
- 앞에서 설명한 정지 대기 방식과 동일
- 1개씩 보내고 ACK/NAK 확인 후 다음 전송

**2. 연속적 ARQ**

**🔸 Go-Back-N ARQ**
- 연속적으로 데이터를 보내다가 NAK를 받으면
- **오류가 발생한 프레임부터 다시 전송**
- 이미 보낸 것도 다시 보내야 함 (비효율적)

**🔸 선택적 ARQ (Selective Repeat ARQ)** ⭐
- **가장 빠른 방식!**
- 오류가 발생한 **해당 프레임만 재전송**
- 이미 보낸 정상 프레임은 재전송하지 않음
- 전송 효율이 가장 높음

**3. 적응형 ARQ (Adaptive ARQ)**
- 데이터 블록의 **길이를 동적으로 조절**
- 오류율에 따라 프레임 크기를 조정하여 최적화

---

### 5. 오류 검출 방식 🔍

#### 📍 패리티 비트 검사 (Parity Bit Check)

**원리:** 1의 개수를 세어서 홀수/짝수 여부 검사

- **홀수 패리티:** 전체 1의 개수가 **홀수**가 되도록 패리티 비트 추가
- **짝수 패리티:** 전체 1의 개수가 **짝수**가 되도록 패리티 비트 추가

**예시 (홀수 패리티):**
```
데이터: 1011001 (1이 4개 → 짝수)
패리티 비트: 1 추가
전송: 10110011 (1이 5개 → 홀수)
```

**구조:**
- MSB (Most Significant Bit): 최상위 비트
- LSB (Least Significant Bit): 최하위 비트
- PB (Parity Bit): 패리티 비트

**단점:** ❌ 오류가 짝수 개 발생하면 검출 불가능

---

#### 📍 블록 합 검사 (Block Sum Check / Checksum)

**동작 방식:**
1. 데이터를 블록 단위로 나눔
2. 각 블록을 **반가산기 방식**으로 더함 (Carry 무시)
3. 합계를 체크섬(Checksum)으로 전송
4. 수신 측에서 다시 계산하여 비교
5. 같으면 ACK, 다르면 NAK

**수평 패리티 검사:**
- 어느 위치에서 오류가 발생했는지 **검출 가능**
- 수신 측에서 해당 비트를 **반전**시켜 오류 정정 가능

---

#### 📍 순환 중복 검사 (CRC: Cyclic Redundancy Check) 🔥🔥🔥

> **매우 중요! 시험 필수 출제!**

**특징:**
- 오류 **검출** 방식 (오류 수정 X, FEC 아님)
- 가장 강력한 오류 검출 기법

**핵심 용어:**
- **M(x)**: 원본 데이터 (메시지)
- **G(x)**: 생성 다항식 (Generator Polynomial, 미리 정해진 값)
- **B(x)**: 원본 데이터 뒤에 0을 r개 붙인 것 (r은 G(x)의 최고차항 차수)
- **A(x)**: B(x)를 G(x)로 나눈 나머지
- **T(x)**: 전송 데이터 = B(x) + A(x)

**송신 측 과정:**
1. 원본 데이터 M(x) 준비
2. G(x)의 최고차항 차수를 r이라 할 때, 원본 데이터 뒤에 0을 r개 붙임 → B(x)
3. B(x)를 G(x)로 나눔 (**XOR 연산 사용**)
4. 나머지 A(x)를 구함 (몫은 버림)
5. T(x) = B(x) + A(x)를 전송

**수신 측 과정:**
1. T(x)를 받음
2. T(x)를 G(x)로 나눔
3. 나머지가 **0**이면 → 정상 데이터 (ACK)
4. 나머지가 **0이 아니면** → 오류 발생 (NAK)

**예시:**
```
M(x) = 1101 (원본 데이터)
G(x) = 1011 (생성 다항식, 최고차항 차수 = 3)

1. B(x) = 원본 데이터 뒤에 0을 3개 붙임 = 1101000

2. B(x) ÷ G(x) (XOR 연산)
   1101000 ÷ 1011 = 나머지 010

3. A(x) = 010

4. T(x) = 1101000 + 010 = 1101010 (전송)

수신 측:
5. 1101010 ÷ 1011 = 나머지 000 → 정상!
```

---

#### 📍 해밍 부호 검사 (Hamming Code) 🔥🔥🔥

> **매우 중요! 시험 필수 출제!**

**특징:**
- ✅ 처리 속도가 빠름
- ✅ 실시간 처리 가능
- ✅ 오류 **검출 + 정정** 모두 가능

**원리:**
- 데이터에 **패리티 비트**를 추가하여 오류 위치를 찾아냄
- 패리티 비트는 **2의 거듭제곱 위치**(1, 2, 4, 8, ...)에 삽입

---

**송신 측: 해밍 부호 생성**

**예시: 8비트 데이터 `10110101`을 전송**

**1단계: 패리티 비트 위치 정하기**
- 2의 거듭제곱 자리(1, 2, 4, 8)에 패리티 비트 삽입
- 나머지 자리에 원본 데이터 삽입

```
위치:  1  2  3  4  5  6  7  8  9 10 11 12
데이터: P1 P2 1  P4 0  1  1  P8 0  1  0  1
       (패리티 비트는 나중에 계산)
```

**2단계: 각 패리티 비트 계산**

각 패리티 비트는 **자신의 위치 번호를 이진수로 표현했을 때 해당 비트가 1인 위치들**을 검사합니다.

- **P1 (위치 1 = 0001₂)**: 1번째 비트가 1인 모든 위치
  - 검사 위치: 1, 3, 5, 7, 9, 11 → `P1, 1, 0, 1, 0, 0`
  - 1의 개수가 **짝수**가 되도록 P1 설정 (짝수 패리티)
  - 1의 개수 = 2개 → P1 = **0**

- **P2 (위치 2 = 0010₂)**: 2번째 비트가 1인 모든 위치
  - 검사 위치: 2, 3, 6, 7, 10, 11 → `P2, 1, 1, 1, 1, 0`
  - 1의 개수 = 4개 → P2 = **0**

- **P4 (위치 4 = 0100₂)**: 3번째 비트가 1인 모든 위치
  - 검사 위치: 4, 5, 6, 7, 12 → `P4, 0, 1, 1, 1`
  - 1의 개수 = 3개 → P4 = **1**

- **P8 (위치 8 = 1000₂)**: 4번째 비트가 1인 모든 위치
  - 검사 위치: 8, 9, 10, 11, 12 → `P8, 0, 1, 0, 1`
  - 1의 개수 = 2개 → P8 = **0**

**최종 전송 데이터:**
```
위치:  1  2  3  4  5  6  7  8  9 10 11 12
데이터: 0  0  1  1  0  1  1  0  0  1  0  1
```

---

**수신 측: 오류 검출 및 정정**

**전송 중 7번 위치에 오류 발생:**
```
수신 데이터: 0  0  1  1  0  1  0  0  0  1  0  1
                              ↑ (오류)
```

**1단계: 각 패리티 비트 재계산**

- **P1 검사**: 1, 3, 5, 7, 9, 11 → `0, 1, 0, 0, 0, 0` → 1의 개수 = 1 (홀수) → **오류 발견!** → S1 = 1
- **P2 검사**: 2, 3, 6, 7, 10, 11 → `0, 1, 1, 0, 1, 0` → 1의 개수 = 3 (홀수) → **오류 발견!** → S2 = 1
- **P4 검사**: 4, 5, 6, 7, 12 → `1, 0, 1, 0, 1` → 1의 개수 = 3 (홀수) → **오류 발견!** → S4 = 1
- **P8 검사**: 8, 9, 10, 11, 12 → `0, 0, 1, 0, 1` → 1의 개수 = 2 (짝수) → 정상 → S8 = 0

**2단계: 신드롬(Syndrome) 계산**

오류 위치 = S8 × 8 + S4 × 4 + S2 × 2 + S1 × 1
         = 0 × 8 + 1 × 4 + 1 × 2 + 1 × 1 
         = 4 + 2 + 1 = 7

→ **7번 위치에 오류 발생!**

**3단계: 오류 정정**
- 7번 위치의 비트를 **반전** (0 → 1)
- 정정된 데이터: `0  0  1  1  0  1  1  0  0  1  0  1` ✅

---

**💡 해밍 부호 꿀팁:**
1. 패리티 비트 개수 r은 다음 조건을 만족해야 함: **2^r ≥ m + r + 1** (m은 데이터 비트 수)
2. 8비트 데이터는 4개의 패리티 비트 필요 → 총 12비트 전송
3. 시험에서는 주로 **오류 위치 찾기** 문제가 출제됨!

---

### 📌 데이터 링크 계층 정리

**키워드:**
`프레임`, `MAC 주소`, `노드 대 노드`, `흐름 제어`, `오류 제어`, `ARQ`, `CRC`, `해밍 부호`

**주요 장비:**
- 스위치 (Switch)
- 브리지 (Bridge)

---

## 3️⃣ 네트워크 계층 (Network Layer) 🌐

**출발지에서 목적지까지의 경로를 설정하고 패킷을 전달합니다.**

### 주요 기능

1. **경로 배정 (Routing)**
   - 최적의 경로를 선택하여 패킷 전달
   - 라우팅 알고리즘 사용

2. **패킷 중계 (Relaying)**
   - 중간 라우터를 거쳐 패킷 전달

3. **상호 통신망 연결 (Internetworking)**
   - 서로 다른 네트워크를 연결

4. **논리적 주소 지정**
   - **IP 주소** 사용
   - 네트워크 전체에서 유일한 주소

5. **통신망 접속**
   - 다른 네트워크와의 접속 관리

6. **흐름 제어 & 순서 제어**
   - 패킷의 순서를 관리
   - 네트워크 혼잡 제어

### 키워드
`패킷`, `IP 주소`, `라우팅`, `논리적 주소`, `경로 설정`

### 주요 장비
- 라우터 (Router)
- L3 스위치

### 대표 프로토콜
- IP, ICMP, ARP, RARP

---

## 4️⃣ 전송 계층 (Transport Layer) 🚚

**종단 간(End-to-End) 신뢰성 있는 데이터 전송을 보장합니다.**

### 주요 기능

1. **종단 간 연결 (End-to-End Connection)**
   - 송신 측 응용 프로그램과 수신 측 응용 프로그램 간 직접 연결

2. **포트 주소 지정**
   - **포트 번호**를 사용하여 응용 프로그램 구분
   - 예: HTTP(80), HTTPS(443), FTP(21)

3. **다중화 (Multiplexing)**
   - 여러 응용 프로그램이 동시에 네트워크 사용 가능

4. **신뢰성 보장**
   - 데이터 손실, 중복, 순서 오류 방지
   - 연결 지향 서비스(TCP) 제공

5. **흐름 제어 & 오류 제어**
   - 송신 속도 조절
   - 재전송 메커니즘

6. **분할 및 재조립**
   - 메시지를 세그먼트로 나누고 재조립

7. **보안 & 계정 관리**
   - 데이터 암호화 및 사용자 인증

8. **메시지 우선권**
   - 중요한 데이터 우선 처리

### 키워드
`세그먼트`, `포트 번호`, `종단 간`, `신뢰성`, `TCP/UDP`

### 대표 프로토콜
- **TCP** (Transmission Control Protocol): 연결 지향, 신뢰성 보장
- **UDP** (User Datagram Protocol): 비연결 지향, 빠른 전송

---

## 5️⃣ 세션 계층 (Session Layer) 🔗

**응용 프로그램 간의 연결(세션)을 설정, 관리, 종료합니다.**

### 주요 기능

1. **세션 설정 (Session Establishment)**
   - 통신을 시작하기 위한 연결 생성

2. **세션 유지 (Session Maintenance)**
   - 통신 중 연결 상태 관리
   - 동기화(Synchronization) 포인트 설정

3. **세션 종료 (Session Termination)**
   - 통신 종료 시 세션 정리

4. **대화 제어 (Dialog Control)**
   - 반이중(Half-Duplex), 전이중(Full-Duplex) 통신 관리

5. **동기화 (Synchronization)**
   - 체크포인트 설정으로 오류 발생 시 재시작 지점 제공

### 키워드
`세션`, `동기화`, `대화 제어`, `체크포인트`

### 대표 프로토콜
- NetBIOS, RPC, SSH

---

## 6️⃣ 표현 계층 (Presentation Layer) 🎨

**데이터의 형식을 변환하고 암호화/복호화를 담당합니다.**

### 주요 기능

1. **코드 변환 (Code Conversion)**
   - ASCII, EBCDIC, 유니코드 등 문자 코드 변환
   - 서로 다른 시스템 간 데이터 호환성 제공

2. **데이터 압축 (Data Compression)**
   - 전송 효율 향상을 위한 데이터 압축

3. **데이터 암호화 (Encryption)**
   - 보안을 위한 데이터 암호화 및 복호화

4. **명령어 해석**
   - 응용 계층의 명령을 네트워크 형식으로 변환

5. **구문 변환 (Syntax Conversion)**
   - 데이터 표현 형식 변환 (예: JSON, XML)

### 키워드
`암호화`, `코드 변환`, `데이터 형식`, `ASCII`, `압축`

### 대표 프로토콜
- SSL/TLS, JPEG, MPEG, ASCII

---

## 7️⃣ 응용 계층 (Application Layer) 💻

**사용자와 직접 상호작용하는 최상위 계층입니다.**

### 주요 기능

1. **사용자 인터페이스 제공**
   - 사용자가 네트워크 서비스에 접근할 수 있도록 인터페이스 제공

2. **네트워크 서비스 제공**
   - 이메일, 파일 전송, 웹 브라우징 등

3. **응용 프로그램 지원**
   - 엑셀, 워드, 웹 브라우저 등 응용 프로그램이 동작하는 계층

### 키워드
`사용자 인터페이스`, `이메일`, `웹`, `FTP`, `HTTP`, `애플리케이션`

### 대표 프로토콜 및 서비스
- **HTTP/HTTPS**: 웹 브라우징
- **FTP**: 파일 전송
- **SMTP**: 이메일 전송
- **DNS**: 도메인 이름 해석
- **DHCP**: IP 주소 자동 할당

---

## 📊 OSI 7계층 비교표

| 계층 | 이름 | PDU | 주소 | 주요 기능 | 장비 | 프로토콜 예시 |
|------|------|-----|------|-----------|------|---------------|
| 7 | 응용 | 데이터 | - | 사용자 인터페이스 | - | HTTP, FTP, SMTP |
| 6 | 표현 | 데이터 | - | 암호화, 코드 변환 | - | SSL, JPEG |
| 5 | 세션 | 데이터 | - | 세션 관리 | - | NetBIOS, SSH |
| 4 | 전송 | 세그먼트 | 포트 번호 | 종단 간 신뢰성 | 게이트웨이 | TCP, UDP |
| 3 | 네트워크 | 패킷 | IP 주소 | 경로 설정 | 라우터 | IP, ICMP |
| 2 | 데이터 링크 | 프레임 | MAC 주소 | 노드 간 전달 | 스위치, 브리지 | 이더넷 |
| 1 | 물리 | 비트 | - | 비트 전송 | 허브, 리피터 | - |

> **PDU (Protocol Data Unit)**: 각 계층에서 처리하는 데이터의 단위

---

## 🎯 시험 대비 핵심 암기 사항

### 1. 각 계층의 핵심 키워드
- **물리**: 비트, 전기 신호
- **데이터 링크**: 프레임, MAC 주소, 오류 제어, CRC, 해밍 부호
- **네트워크**: 패킷, IP 주소, 라우팅
- **전송**: 세그먼트, 포트 번호, TCP/UDP
- **세션**: 세션 관리, 동기화
- **표현**: 암호화, 코드 변환
- **응용**: 사용자 인터페이스, HTTP/FTP

### 2. 주소 체계 암기
- **데이터 링크 계층**: MAC 주소 (물리적 주소)
- **네트워크 계층**: IP 주소 (논리적 주소)
- **전송 계층**: 포트 번호 (응용 프로그램 식별)

### 3. 오류 제어 방식 비교
| 방식 | 검출 | 정정 | 효율성 |
